[{"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw":
    "/-|\n==================================================\n Literate programming with Alectryon (Lean4 input)\n==================================================\n\nAlectryon supports literate programs and documents (combinations of code and prose) written in Lean4 and reStructuredText.  Here is an example written in Lean4.  It can be converted to reST, HTML, or LaTeX using the following commands::\n\n   alectryon literate_lean4.lean\n       # Lean4+reST → HTML;  produces ‘literate_lean4.html’\n   alectryon literate_lean4.lean --backend latex \\\n        --latex-dialect xelatex \\\n        -o literate_lean4.xe.tex\n       # Lean4+reST → LaTeX; produces ‘literate_lean4.xe.tex’\n   alectryon literate_lean4.lean --backend rst\n       # Lean4+reST → reST;  produces ‘literate_lean4.lean.rst’\n\n-----\n\n.. default-role:: lean4\n\nRunning queries\n===============\n\nAlectryon captures the results of `#check`, `#eval`, and the like:\n-/\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "10\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "#reduce",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    "\n\n/-|\nBy default, these results are folded and are displayed upon hovering or clicking.  We can unfold them by default using annotations or directives:\n-/\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "Nat : Type\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "#check",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Nat",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " /- .unfold -/\n\n/-|\n.. lean4:: unfold\n-/\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "Bool : Type\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "#check",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Bool", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Bool",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "2\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " + ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    "\n\n/-| Other flags can be used to control display, like ``.no-in``: -/\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages":
  [{"contents":
    "inductive Iff : Prop → Prop → Prop\nconstructors:\nIff.intro : ∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)\n",
    "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "#print",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Prop → Prop → Prop", "name": "Iff", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Iff",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    " /- .unfold .no-in -/\n\n/-|\nDocumenting proofs\n==================\n\nAlectryon also captures goals and hypotheses as proofs progress:\n-/\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "theorem",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ (p q : Prop), p → q → (p ∧ q ↔ q ∧ p)",
     "name": "test",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "test",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Prop", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prop",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "p", "name": "hp", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "q", "name": "hq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "): ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ∧ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ↔ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "q", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "q",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ∧ ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Prop", "name": "p", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "p",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "by",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"},
     {"type": "p", "names": ["hp"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ∧ q → q ∧ p",
    "_type": "goal"},
   {"name": "mpr",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"},
     {"type": "p", "names": ["hp"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ∧ p → p ∧ q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
     "name": "Iff.intro",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "Iff.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"},
     {"type": "p", "names": ["hp"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ∧ q → q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring":
    "Introduce one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must be a `let` or function type.\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses can be anonymized via `_`,\n  or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "mp",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"},
     {"type": "p", "names": ["hp"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"},
     {"type": "p ∧ q", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ∧ p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduce one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must be a `let` or function type.\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses can be anonymized via `_`,\n  or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"},
     {"type": "p", "names": ["hp"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"},
     {"type": "p ∧ q", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"},
   {"name": "mp.right",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"},
     {"type": "p", "names": ["hp"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"},
     {"type": "p ∧ q", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → b → a ∧ b",
     "name": "And.intro",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "And.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "mp.left",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"},
     {"type": "p", "names": ["hp"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"},
     {"type": "p ∧ q", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "q", "name": "hq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "mp.right",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"},
     {"type": "p", "names": ["hp"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"},
     {"type": "p ∧ q", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "p", "name": "hp", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "mpr",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"},
     {"type": "p", "names": ["hp"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q ∧ p → p ∧ q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring":
    "Introduce one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must be a `let` or function type.\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses can be anonymized via `_`,\n  or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "mpr",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"},
     {"type": "p", "names": ["hp"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"},
     {"type": "q ∧ p", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p ∧ q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "intro",
    "link": null,
    "docstring":
    "Introduce one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must be a `let` or function type.\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses can be anonymized via `_`,\n  or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " h",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"},
     {"type": "p", "names": ["hp"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"},
     {"type": "q ∧ p", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"},
   {"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"},
     {"type": "p", "names": ["hp"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"},
     {"type": "q ∧ p", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "apply",
    "link": null,
    "docstring":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "∀ {a b : Prop}, a → b → a ∧ b",
     "name": "And.intro",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "And.intro",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "mpr.left",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"},
     {"type": "p", "names": ["hp"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"},
     {"type": "q ∧ p", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "p",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "p", "name": "hp", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hp",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [],
  "goals":
  [{"name": "mpr.right",
    "hypotheses":
    [{"type": "Prop", "names": ["p", "q"], "body": "", "_type": "hypothesis"},
     {"type": "p", "names": ["hp"], "body": "", "_type": "hypothesis"},
     {"type": "q", "names": ["hq"], "body": "", "_type": "hypothesis"},
     {"type": "q ∧ p", "names": ["h"], "body": "", "_type": "hypothesis"}],
    "conclusion": "q",
    "_type": "goal"}],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "exact",
    "link": null,
    "docstring":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Name.Variable",
    "raw": "",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "q", "name": "hq", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "hq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"}]